import config from "~/config";

export class Docs {
  articles: Record<string, () => Promise<Article>> = {};
  navLinks: NavLink[] = [];
  async init() {
    this.articles = Object.fromEntries(
      Object.entries(import.meta.glob<Article>("../routes/docs/**/*.md")).map(
        ([key, fn]) => [key.slice("../routes/docs/".length, -".md".length), fn],
      ),
    );
    this.navLinks = await Promise.all(
      config.navLinks.map((navLink) => this.#normalizeNavLink(navLink)),
    );
    return this;
  }

  async #normalizeNavLink(navLink: RawNavLink): Promise<NavLink> {
    if (typeof navLink === "string") {
      const article = this.articles[navLink];
      if (!article) {
        throw new Error(`Doc not found: ${navLink}`);
      }
      return {
        label: (await article()).frontmatter.title,
        link: `/${navLink}`,
        external: false,
      };
    }

    if ("items" in navLink) {
      return {
        ...navLink,
        collapsed: !!navLink.collapsed,
        badge: normalizeBadge(navLink.badge),
        items: await Promise.all(
          navLink.items.map((navLink) => this.#normalizeNavLink(navLink)),
        ),
      };
    }

    if ("slug" in navLink) {
      const article = this.articles[navLink.slug];
      if (!article) {
        throw new Error(`Doc not found: ${navLink.slug}`);
      }
      return {
        label: navLink.label ?? (await article()).frontmatter.title,
        link: `/${navLink.slug}`,
        badge: normalizeBadge(navLink.badge),
        external: false,
      };
    }

    if ("autogenerate" in navLink) {
      const dir = navLink.autogenerate.directory;
      const articleEntries = Object.entries(this.articles).filter(([key]) =>
        key.startsWith(dir + "/"),
      );

      const frontmatters = await Promise.all(
        articleEntries.map(async ([key, article]) => ({
          key,
          frontmatter: (await article()).frontmatter,
        })),
      );

      let titleMissing = false;
      // Check frontmatter for title
      for (const item of frontmatters) {
        if (!item.frontmatter.title) {
          console.error(
            `Missing title in frontmatter for autogenerated doc: ${item.key}`,
          );
          titleMissing = true;
        }
      }
      if (titleMissing) throw new Error("Aborting due to errors.");

      const items: NavLink[] = await Promise.all(
        frontmatters
          .sort((a, b) => {
            const orderA = a.frontmatter.order;
            const orderB = b.frontmatter.order;
            if (orderA != null && orderB != null) {
              return orderA - orderB;
            }
            if (orderA != null) {
              return -1;
            }
            if (orderB != null) {
              return 1;
            }
            const titleA = a.frontmatter.title ?? a.key;
            const titleB = a.frontmatter.title ?? a.key;
            return titleA.localeCompare(titleB.title);
          })
          .map((item) =>
            this.#normalizeNavLink({
              label: item.frontmatter.title,
              link: `/${item.key}`,
            }),
          ),
      );
      return {
        label: navLink.label ?? dir.split("/").slice(-1)[0],
        items,
        collapsed: !!navLink.collapsed,
        badge: normalizeBadge(navLink.badge),
      };
    }

    return {
      ...navLink,
      badge: normalizeBadge(navLink.badge),
      external: /^(https?:)?\/\//.test(navLink.link),
    };
  }
}

export type RawNavLink =
  | string
  | {
      label: string;
      items: RawNavLink[];
      collapsed?: boolean;
      badge?: RawBadge;
    }
  | {
      label: string;
      autogenerate: { directory: string };
      collapsed?: boolean;
      badge?: RawBadge;
    }
  | {
      label?: string;
      slug: string;
      badge?: RawBadge;
    }
  | {
      label: string;
      link: string;
      badge?: RawBadge;
    };

export type NavLink =
  | {
      label: string;
      items: NavLink[];
      collapsed: boolean;
      badge?: Badge;
    }
  | {
      label: string;
      link: string;
      badge?: Badge;
      external: boolean;
    };

export type RawBadge = string | Badge;

export type Badge = {
  text: string;
  variant: "caution" | "normal";
};

export type Article = {
  content: string;
  frontmatter: Record<string, any>;
  toc: string;
};

function normalizeBadge(badge: RawBadge | undefined): Badge | undefined {
  if (!badge) {
    return undefined;
  }
  if (typeof badge === "string") {
    return {
      text: badge,
      variant: "normal",
    };
  }
  return badge;
}
