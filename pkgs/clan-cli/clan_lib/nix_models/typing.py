# DO NOT EDIT THIS FILE MANUALLY. IT IS GENERATED.
# This file was generated by running `pkgs/clan-cli/clan_lib/nix_models/update.sh`
#
# fmt: off

from typing import Literal, NotRequired, ReadOnly, TypedDict

type AnyJson = bool | int | float | str | list[AnyJson] | dict[str, AnyJson] | None


type ClanMachinesInput = dict[str, AnyJson]
"""
A mapping of machine names to their nixos configuration.

???+ example

    ```nix
    machines = {
      my-machine = {
        # Your nixos configuration
      };
    };
    ```

"""


type ClanMachinesOutput = dict[str, AnyJson]
"""
A mapping of machine names to their nixos configuration.

???+ example

    ```nix
    machines = {
      my-machine = {
        # Your nixos configuration
      };
    };
    ```

"""


type ClanModulesInput = dict[str, AnyJson]
"""
An attribute set of exported modules.

"""


type ClanModulesOutput = dict[str, AnyJson]
"""
An attribute set of exported modules.

"""


class EmptyDictInput(TypedDict):
    pass


class InstanceModuleInput(TypedDict):
    input: NotRequired[str | None]
    """
    Name of the input. Default to 'null' which means the module is local

    """
    name: NotRequired[str]
    """
    Attribute of the clan service module imported from the chosen input.

    Defaults to the name of the instance.

    """


class InstanceModuleOutput(TypedDict):
    input: ReadOnly[str | None]
    """
    Name of the input. Default to 'null' which means the module is local

    """
    name: ReadOnly[str]
    """
    Attribute of the clan service module imported from the chosen input.

    Defaults to the name of the instance.

    """


type InstanceRoleExtraModulesInput = list[AnyJson]
"""
List of additionally imported `.nix` expressions.

!!! Note
    **The import only happens if the machine is part of the service or role.**

Other types are passed through to the nixos configuration.

???+ Example
    To import the `special.nix` file

    ```
    . Clan Directory
    ├── flake.nix
    ...
    └── modules
        ├── special.nix
        └── ...
    ```

    ```nix
    {
      extraModules = [ "modules/special.nix" ];
    }
    ```

"""


type InstanceRoleExtraModulesOutput = list[AnyJson]
"""
List of additionally imported `.nix` expressions.

!!! Note
    **The import only happens if the machine is part of the service or role.**

Other types are passed through to the nixos configuration.

???+ Example
    To import the `special.nix` file

    ```
    . Clan Directory
    ├── flake.nix
    ...
    └── modules
        ├── special.nix
        └── ...
    ```

    ```nix
    {
      extraModules = [ "modules/special.nix" ];
    }
    ```

"""


class InstanceRoleMachineInput(TypedDict):
    settings: NotRequired[AnyJson]


class InstanceRoleMachineOutput(TypedDict):
    settings: ReadOnly[AnyJson]


type InstanceRoleMachinesInput = dict[str, InstanceRoleMachineInput]


type InstanceRoleMachinesOutput = dict[str, InstanceRoleMachineOutput]


type InstanceRoleTagDictInput = dict[str, EmptyDictInput]


type InstanceRoleTagListInput = list[str]


class InstanceRoleTagOutput(TypedDict):
    pass


type InstanceRoleTagsInput = InstanceRoleTagListInput | InstanceRoleTagDictInput


type InstanceRoleTagsOutput = dict[str, InstanceRoleTagOutput]


class InventoryMetaInput(TypedDict):
    description: NotRequired[str | None]
    """
    Optional freeform description

    """
    domain: NotRequired[str]
    """
    Domain for the clan.

    It will be used to wire clan-internal services and resolve the address
    for each machine of the clan using `<hostname>.<meta.domain>`

    This can either be:

    - A top level domain (TLD). Set this to a valid, but not already
      existing TLD if you're using a mesh network between your machines.
      This will route requests between your machines over the mesh network.

    - A regular domain. Set this to a valid domain you own if you want
      to route requests between your machines over the public internet.
      You will have to manually setup your public DNS of that domain to
      route `<hostname>.<meta.domain>` to each of your machines.

    """
    icon: NotRequired[str | None]
    """
    Under construction, will be used for the UI

    """
    name: str
    """
    Name of the clan.

    Needs to be (globally) unique, as this determines the folder name where the flake gets downloaded to.

    Should only contain alphanumeric characters, `_` and `-`.

    """
    tld: NotRequired[str | None]
    """
    Deprecated: Use `domain` instead.

    """


class InventoryMetaOutput(TypedDict):
    description: ReadOnly[str | None]
    """
    Optional freeform description

    """
    domain: ReadOnly[str]
    """
    Domain for the clan.

    It will be used to wire clan-internal services and resolve the address
    for each machine of the clan using `<hostname>.<meta.domain>`

    This can either be:

    - A top level domain (TLD). Set this to a valid, but not already
      existing TLD if you're using a mesh network between your machines.
      This will route requests between your machines over the mesh network.

    - A regular domain. Set this to a valid domain you own if you want
      to route requests between your machines over the public internet.
      You will have to manually setup your public DNS of that domain to
      route `<hostname>.<meta.domain>` to each of your machines.

    """
    icon: ReadOnly[str | None]
    """
    Under construction, will be used for the UI

    """
    name: ReadOnly[str]
    """
    Name of the clan.

    Needs to be (globally) unique, as this determines the folder name where the flake gets downloaded to.

    Should only contain alphanumeric characters, `_` and `-`.

    """
    tld: ReadOnly[str | None]
    """
    Deprecated: Use `domain` instead.

    """


type InventoryModulesInput = dict[str, AnyJson]
"""
A mapping of module names to their path.

Each module can be referenced by its `attributeName` in the `inventory.services` attribute set.

!!! Important
    Each module MUST fulfill the following requirements to be usable with the inventory:

    - The module MUST have a `README.md` file with a `description`.
    - The module MUST have at least `features = [ "inventory" ]` in the frontmatter section.
    - The module MUST have a subfolder `roles` with at least one `{roleName}.nix` file.

    For further information see: [Module Authoring Guide](../../guides/services/community.md).

???+ example
    ```nix
    clan-core.lib.clan {
        # 1. Add the module to the available inventory modules
        inventory.modules = {
          custom-module = ./modules/my_module;
        };
        # 2. Use the module in the inventory
        inventory.services = {
          custom-module.instance_1 = {
              roles.default.machines = [ "machineA" ];
          };
        };
    };
    ```

"""


type InventoryModulesOutput = dict[str, AnyJson]
"""
A mapping of module names to their path.

Each module can be referenced by its `attributeName` in the `inventory.services` attribute set.

!!! Important
    Each module MUST fulfill the following requirements to be usable with the inventory:

    - The module MUST have a `README.md` file with a `description`.
    - The module MUST have at least `features = [ "inventory" ]` in the frontmatter section.
    - The module MUST have a subfolder `roles` with at least one `{roleName}.nix` file.

    For further information see: [Module Authoring Guide](../../guides/services/community.md).

???+ example
    ```nix
    clan-core.lib.clan {
        # 1. Add the module to the available inventory modules
        inventory.modules = {
          custom-module = ./modules/my_module;
        };
        # 2. Use the module in the inventory
        inventory.services = {
          custom-module.instance_1 = {
              roles.default.machines = [ "machineA" ];
          };
        };
    };
    ```

"""


type InventoryTagMachinesInput = list[str]
"""
!!! example "Predefined Tag"

    Will be added to all machines that set `machineClass = "nixos"`

    ```nix
    inventory.machines.machineA.tags = [ "nixos" ];
    ```

"""


type InventoryTagMachinesOutput = list[str]
"""
!!! example "Predefined Tag"

    Will be added to all machines that set `machineClass = "nixos"`

    ```nix
    inventory.machines.machineA.tags = [ "nixos" ];
    ```

"""


class InventoryTagsInput(TypedDict):
    """
    Tags of the inventory are used to group machines together.

    It is recommended to use [`machine.tags`](#inventory.machines.tags) to define the tags of the machines.

    This can be used to define custom tags that are either statically set or dynamically computed.

    #### Static Tags

    ???+ example "Static Tag Example"
        ```nix
        inventory.tags = {
          foo = [ "machineA" "machineB" ];
        };
        ```

        The tag `foo` will always be added to `machineA` and `machineB`.

    #### Dynamic Tags

    It is possible to compute tags based on the machines properties or based on other tags.

    !!! danger
        This is a powerful feature and should be used with caution.

        It is possible to cause infinite recursion by computing tags based on the machines properties or based on other tags.

    ???+ example "Dynamic Tag Example"

        allButFoo is a computed tag. It will be added to all machines except 'foo'

        `all` is a predefined tag. See the docs of [`tags.all`](#inventory.tags.all).

        ```nix
        #  inventory.tags ↓       ↓ inventory.machines
        inventory.tags = {config, machines...}: {
          #                                                        ↓↓↓ The "all" tag
          allButFoo = builtins.filter (name: name != "foo") config.all;
        };
        ```

    !!! warning
        Do NOT compute `tags` from `machine.tags` this will cause infinite recursion.

    """

    all: NotRequired[InventoryTagMachinesInput]
    darwin: NotRequired[InventoryTagMachinesInput]
    nixos: NotRequired[InventoryTagMachinesInput]


class InventoryTagsOutput(TypedDict):
    """
    Tags of the inventory are used to group machines together.

    It is recommended to use [`machine.tags`](#inventory.machines.tags) to define the tags of the machines.

    This can be used to define custom tags that are either statically set or dynamically computed.

    #### Static Tags

    ???+ example "Static Tag Example"
        ```nix
        inventory.tags = {
          foo = [ "machineA" "machineB" ];
        };
        ```

        The tag `foo` will always be added to `machineA` and `machineB`.

    #### Dynamic Tags

    It is possible to compute tags based on the machines properties or based on other tags.

    !!! danger
        This is a powerful feature and should be used with caution.

        It is possible to cause infinite recursion by computing tags based on the machines properties or based on other tags.

    ???+ example "Dynamic Tag Example"

        allButFoo is a computed tag. It will be added to all machines except 'foo'

        `all` is a predefined tag. See the docs of [`tags.all`](#inventory.tags.all).

        ```nix
        #  inventory.tags ↓       ↓ inventory.machines
        inventory.tags = {config, machines...}: {
          #                                                        ↓↓↓ The "all" tag
          allButFoo = builtins.filter (name: name != "foo") config.all;
        };
        ```

    !!! warning
        Do NOT compute `tags` from `machine.tags` this will cause infinite recursion.

    """

    all: ReadOnly[InventoryTagMachinesOutput]
    darwin: ReadOnly[InventoryTagMachinesOutput]
    nixos: ReadOnly[InventoryTagMachinesOutput]


type MachineClassInput = Literal["nixos", "darwin"]
"""
The module system that should be used to construct the machine

Set this to `darwin` for macOS machines

"""


type MachineClassOutput = Literal["nixos", "darwin"]
"""
The module system that should be used to construct the machine

Set this to `darwin` for macOS machines

"""


class MachineDeployInput(TypedDict):
    buildHost: NotRequired[str | None]
    """
    SSH address of the host to build the machine on
    """
    targetHost: NotRequired[str | None]
    """
    SSH address of the host to deploy the machine to
    """


class MachineDeployOutput(TypedDict):
    buildHost: ReadOnly[str | None]
    """
    SSH address of the host to build the machine on
    """
    targetHost: ReadOnly[str | None]
    """
    SSH address of the host to deploy the machine to
    """


type MachineTagsInput = list[str]
"""
List of tags for the machine.

The machine can be referenced by its tags in `inventory.services`

???+ Example
    ```nix
    inventory.machines.machineA.tags = [ "tag1" "tag2" ];
    ```

    ```nix
    services.borgbackup."instance_1".roles.client.tags = [ "tag1" ];
    ```

!!! Note
    Tags can be used to determine the membership of the machine in the services.
    Without changing the service configuration, the machine can be added to a service by adding the correct tags to the machine.


"""


type MachineTagsOutput = list[str]
"""
List of tags for the machine.

The machine can be referenced by its tags in `inventory.services`

???+ Example
    ```nix
    inventory.machines.machineA.tags = [ "tag1" "tag2" ];
    ```

    ```nix
    services.borgbackup."instance_1".roles.client.tags = [ "tag1" ];
    ```

!!! Note
    Tags can be used to determine the membership of the machine in the services.
    Without changing the service configuration, the machine can be added to a service by adding the correct tags to the machine.


"""


type SecretsAgePluginsInput = list[str]
"""
A list of age plugins which must be available in the shell when encrypting and decrypting secrets.

"""


type SecretsAgePluginsOutput = list[str]
"""
A list of age plugins which must be available in the shell when encrypting and decrypting secrets.

"""


class TemplateClanInput(TypedDict):
    description: NotRequired[str]
    """
    The name of the template.

    """
    path: str
    """
    Holds the path to the clan template.

    """


class TemplateClanOutput(TypedDict):
    description: ReadOnly[str]
    """
    The name of the template.

    """
    path: ReadOnly[str]
    """
    Holds the path to the clan template.

    """


class TemplateDiskoInput(TypedDict):
    description: NotRequired[str]
    """
    The name of the template.

    """
    path: str
    """
    Holds the path to the clan template.

    """


class TemplateDiskoOutput(TypedDict):
    description: ReadOnly[str]
    """
    The name of the template.

    """
    path: ReadOnly[str]
    """
    Holds the path to the clan template.

    """


class TemplateMachineInput(TypedDict):
    description: NotRequired[str]
    """
    The name of the template.

    """
    path: str
    """
    Holds the path to the clan template.

    """


class TemplateMachineOutput(TypedDict):
    description: ReadOnly[str]
    """
    The name of the template.

    """
    path: ReadOnly[str]
    """
    Holds the path to the clan template.

    """


type TemplatesClanInput = dict[str, TemplateClanInput]
"""
Holds the different clan templates.

"""


type TemplatesClanOutput = dict[str, TemplateClanOutput]
"""
Holds the different clan templates.

"""


type TemplatesDiskoInput = dict[str, TemplateDiskoInput]
"""
Holds different disko templates.

"""


type TemplatesDiskoOutput = dict[str, TemplateDiskoOutput]
"""
Holds different disko templates.

"""


type TemplatesMachineInput = dict[str, TemplateMachineInput]
"""
Holds the different machine templates.

"""


type TemplatesMachineOutput = dict[str, TemplateMachineOutput]
"""
Holds the different machine templates.

"""


class TemplatesOutput(TypedDict):
    """
    Define Clan templates.

    """

    clan: ReadOnly[TemplatesClanOutput]
    disko: ReadOnly[TemplatesDiskoOutput]
    machine: ReadOnly[TemplatesMachineOutput]


class InstanceRoleInput(TypedDict):
    extraModules: NotRequired[InstanceRoleExtraModulesInput]
    machines: NotRequired[InstanceRoleMachinesInput]
    settings: NotRequired[AnyJson]
    tags: NotRequired[InstanceRoleTagsInput]


class InstanceRoleOutput(TypedDict):
    extraModules: ReadOnly[InstanceRoleExtraModulesOutput]
    machines: ReadOnly[InstanceRoleMachinesOutput]
    settings: ReadOnly[AnyJson]
    tags: ReadOnly[InstanceRoleTagsOutput]


type InstanceRolesInput = dict[str, InstanceRoleInput]


type InstanceRolesOutput = dict[str, InstanceRoleOutput]


class MachineInput(TypedDict):
    deploy: MachineDeployInput
    description: NotRequired[str | None]
    """
    Optional freeform description

    """
    icon: NotRequired[str | None]
    """
    Under construction, will be used for the UI

    """
    installedAt: NotRequired[int | None]
    """
    Indicates when the machine was first installed.

    Timestamp is in unix time (seconds since epoch).

    """
    machineClass: NotRequired[MachineClassInput]
    name: NotRequired[str]
    """
    Name of the machine or service

    """
    tags: NotRequired[MachineTagsInput]


class MachineOutput(TypedDict):
    deploy: ReadOnly[MachineDeployOutput]
    description: ReadOnly[str | None]
    """
    Optional freeform description

    """
    icon: ReadOnly[str | None]
    """
    Under construction, will be used for the UI

    """
    installedAt: ReadOnly[int | None]
    """
    Indicates when the machine was first installed.

    Timestamp is in unix time (seconds since epoch).

    """
    machineClass: ReadOnly[MachineClassOutput]
    name: ReadOnly[str]
    """
    Name of the machine or service

    """
    tags: ReadOnly[MachineTagsOutput]


class SecretsAgeInput(TypedDict):
    """
    Secrets related options such as AGE plugins required to encrypt/decrypt secrets using the CLI.

    """

    plugins: NotRequired[SecretsAgePluginsInput]


class SecretsAgeOutput(TypedDict):
    """
    Secrets related options such as AGE plugins required to encrypt/decrypt secrets using the CLI.

    """

    plugins: ReadOnly[SecretsAgePluginsOutput]


class SecretsInput(TypedDict):
    """
    Secrets related options such as AGE plugins required to encrypt/decrypt secrets using the CLI.

    """

    age: NotRequired[SecretsAgeInput]


class SecretsOutput(TypedDict):
    """
    Secrets related options such as AGE plugins required to encrypt/decrypt secrets using the CLI.

    """

    age: ReadOnly[SecretsAgeOutput]


class TemplatesInput(TypedDict):
    """
    Define Clan templates.

    """

    clan: NotRequired[TemplatesClanInput]
    disko: NotRequired[TemplatesDiskoInput]
    machine: NotRequired[TemplatesMachineInput]


class InstanceInput(TypedDict):
    module: NotRequired[InstanceModuleInput]
    roles: NotRequired[InstanceRolesInput]


class InstanceOutput(TypedDict):
    module: ReadOnly[InstanceModuleOutput]
    roles: ReadOnly[InstanceRolesOutput]


type InstancesInput = dict[str, InstanceInput]
"""
Multi host service module instances
"""


type InstancesOutput = dict[str, InstanceOutput]
"""
Multi host service module instances
"""


type InventoryMachinesInput = dict[str, MachineInput]
"""
Machines in the inventory.

Each machine declared here can be referencd via its `attributeName` by the `inventory.service`s `roles`.

"""


type InventoryMachinesOutput = dict[str, MachineOutput]
"""
Machines in the inventory.

Each machine declared here can be referencd via its `attributeName` by the `inventory.service`s `roles`.

"""


class InventoryOutput(TypedDict):
    """
    The `Inventory` submodule.

    For details see the [Inventory](/reference/options/clan_inventory.md) documentation.

    """

    instances: ReadOnly[InstancesOutput]
    machines: ReadOnly[InventoryMachinesOutput]
    meta: ReadOnly[InventoryMetaOutput]
    modules: ReadOnly[InventoryModulesOutput]
    tags: ReadOnly[InventoryTagsOutput]


class ClanOutput(TypedDict):
    directory: ReadOnly[str]
    """
    The directory containing the clan.

    A typical directory structure could look like this:

    ```
    .
    ├── flake.nix
    ├── assets
    ├── machines
    ├── modules
    └── sops
    ```

    """
    inventory: ReadOnly[InventoryOutput]
    machines: ReadOnly[ClanMachinesOutput]
    meta: ReadOnly[AnyJson]
    """
    Global information about the clan.

    """
    modules: ReadOnly[ClanModulesOutput]
    secrets: ReadOnly[SecretsOutput]
    templates: ReadOnly[TemplatesOutput]


class InventoryInput(TypedDict):
    """
    The `Inventory` submodule.

    For details see the [Inventory](/reference/options/clan_inventory.md) documentation.

    """

    instances: NotRequired[InstancesInput]
    machines: NotRequired[InventoryMachinesInput]
    meta: InventoryMetaInput
    modules: NotRequired[InventoryModulesInput]
    tags: NotRequired[InventoryTagsInput]


class ClanInput(TypedDict):
    directory: NotRequired[AnyJson]
    """
    The directory containing the clan.

    A typical directory structure could look like this:

    ```
    .
    ├── flake.nix
    ├── assets
    ├── machines
    ├── modules
    └── sops
    ```

    """
    inventory: NotRequired[InventoryInput]
    machines: NotRequired[ClanMachinesInput]
    meta: NotRequired[AnyJson]
    """
    Global information about the clan.

    """
    modules: NotRequired[ClanModulesInput]
    secrets: NotRequired[SecretsInput]
    templates: NotRequired[TemplatesInput]
